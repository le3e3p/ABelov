def validBraces(string):
    braces = {"(": ")", "[": "]", "{": "}"}
    stack = []
    for character in string:
        if character in braces.keys():
            stack.append(character)
        else:
            if len(stack) == 0 or braces[stack.pop()] != character:
                return False
    return len(stack) == 0  
    
    def in_array(array1, array2):
    # your code
    res = []
    for a1 in array1:
        for a2 in array2:
            if a1 in a2 and not a1 in res:
                res.append(a1)
    res.sort()
    return res
    
    #from string import ascii_lowercase as LOWER
LOWER = "abcdefghijklmnopqrstuvwxyz"

def encode(message, key, shift, encode=True):
    key = sorted(LOWER, key=f"{key}{LOWER}".index)
    result = []
    for char in message:
        if char in key:
            i = key.index(char)
            char = key[(i + shift) % 26]
            shift = i + 1 if encode else -(key.index(char) + 1)
        result.append(char)
    return "".join(result)
    
def decode(message, key, shift): 
    return encode(message, key, -shift, encode=False)
    
    def nth_chandos_number(n):
    return int((bin(n)+"0")[2:], 5)
    
    from cmath import log as clog
def log(real, imag):
    try:
        lg = clog(complex(real, imag))
        return lg.real, lg.imag
    except ValueError:
        pass
        
        def largest_power(n):
    print(n)
    if n <= 4:
        if n == 1:
            return (0, -1)
        return (1, -1)
    
    #num_of_occurances
    freq = 0
    x = []
    largest = 0
    j = 0
    while 2**largest < n:
        largest += 1
    largest -= 1
    for i in range(2, largest + 1):
        while j ** i < n:
            j += 1
        j -= 1
        x.append(j**i)
        j = 0
    return (max(x), x.count(max(x)))
    def prime_factors (n):
  primes = []
  candidate = 2;
  while n > 1:
    while n % candidate == 0:
        primes.append(candidate)
        n /= candidate
    candidate += 1
  return primes
